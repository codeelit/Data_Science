package codeelit.datascience;


import android.app.Activity;
import android.os.Bundle;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.NavigationView;
import android.support.design.widget.Snackbar;
import android.support.v4.app.Fragment;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.List;

import codeelit.datascience.R;

/**
 * A simple {@link Fragment} subclass.
 */
public class indexing_fragment extends Fragment {
    private RecyclerView recyclerView;
    private RecyclerView.Adapter adapter;
    private List<ListitemNumpy> listitemNumpies;

    NavigationView navigationView;
    public static indexing_fragment newInstance(){
        indexing_fragment introduction_fragement=new indexing_fragment();

        return introduction_fragement;
    }

    public indexing_fragment() {
        // Required empty public constructor
    }


    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View rootView=inflater.inflate( R.layout.fragment_indexing_fragment2,null);

        recyclerView=(RecyclerView) rootView.findViewById( R.id.nav_indexing_RV);
        recyclerView.setHasFixedSize( true );
        recyclerView.setLayoutManager( new LinearLayoutManager( getActivity() ) );
        listitemNumpies=new ArrayList<>(  );


        ListitemNumpy listitemNumpy=new ListitemNumpy(
                "Indexing",
                " ndarrays can be indexed using the standard Python x[obj] syntax, where" +
                        " x is the array and obj the selection. There are three kinds of indexing " +
                        "available: field access, basic slicing, advanced indexing. Which one occurs " +
                        "depends on obj.");
        listitemNumpies.add(listitemNumpy);
        ListitemNumpy listitemNump=new ListitemNumpy(
                "Basic Slicing and Indexing",
                "->Basic slicing extends Python’s basic concept of slicing to N dimensions\n" +
                        "->Basic slicing occurs when obj is a slice object (constructed by start:stop:step" +
                        " notation inside of brackets), an integer, or a tuple of slice objects and integers. \n" +
                        "->Ellipsis and newaxis objects can be interspersed with these as well. In " +
                        "order to remain backward compatible with a common usage in Numeric, basic slicing is also initiated if the selection object is any non-ndarray sequence (such as a list) containing slice objects, the Ellipsis object, or the newaxis object, but not for integer arrays or other embedded sequences.\n" +
                        "The simplest case of indexing with N integers returns an array scalar representing the corresponding item. As in Python, all indices are zero-based: for the i-th index n_i, the valid range is 0 \\le n_i < d_i where d_i is the i-th element of the shape of the array. Negative indices are interpreted as counting from the end of the array (i.e., if n_i < 0, it means n_i + d_i).");
        listitemNumpies.add(listitemNump);
        ListitemNumpy listitemNum=new ListitemNumpy(
                "All arrays generated by basic slicing are always views of the original array.",
                "The standard rules of sequence slicing apply to basic slicing on a per-dimension basis " +
                        "--> The basic slice syntax is i:j:k where i is the starting index, j is the stopping index, and k is the step (k\\neq0). This selects the m elements (in the corresponding dimension) with index values i, i + k, …, i + (m - 1) k where m = q + (r\\neq0) and q and r are the quotient and remainder obtained by dividing j - i by k: j - i = q k + r, so that i + (m - 1) k < j."
                        );
        listitemNumpies.add(listitemNum);
        ListitemNumpy listitemNu=new ListitemNumpy(
                "Example",
                ">>> x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n" +
                        ">>> x[1:7:2]\n" +
                        "array([1, 3, 5])");
        listitemNumpies.add(listitemNu);
        ListitemNumpy listitemN=new ListitemNumpy(
                "Example",
                ">>> dt = np.dtype('>i4')\n" +
                        ">>> dt.byteorder\n" +
                        "'>'\n" +
                        ">>> dt.itemsize\n" +
                        "4\n" +
                        ">>> dt.name\n" +
                        "'int32'\n" +
                        ">>> dt.type is np.int32\n" +
                        "True"+"\n-->Negative i and j are interpreted as n + i and n + j where n is the number of elements in the corresponding dimension. Negative k makes stepping go towards smaller indices.");
        listitemNumpies.add(listitemN);
        ListitemNumpy listitem=new ListitemNumpy(
                "Example",
                ">>> x[-2:10]\n" +
                        "array([8, 9])\n" +
                        ">>> x[-3:3:-1]\n" +
                        "array([7, 6, 5, 4])"+"\n-->Assume n is the number of elements in the dimension being sliced. Then, if i is not given it defaults to 0 for k > 0 and n - 1 for k < 0 . If j is not given it defaults to n for k > 0 and -n-1 for k < 0 . If k is not given it defaults to 1. Note that :: is the same as : and means select all indices along this axis.");
        listitemNumpies.add(listitem);
        ListitemNumpy listite=new ListitemNumpy(
                "Example",
                ">>> x[5:]\n" +
                        "array([5, 6, 7, 8, 9])"+"\n-->If the number of objects in the selection tuple is less than N , then : is assumed for any subsequent dimensions.");
        listitemNumpies.add(listite);
        ListitemNumpy listit=new ListitemNumpy(
                "Example",
                ">>> x = np.array([[[1],[2],[3]], [[4],[5],[6]]])\n" +
                        ">>> x.shape\n" +
                        "(2, 3, 1)\n" +
                        ">>> x[1:2]\n" +
                        "array([[[4],\n" +
                        "        [5],\n" +
                        "        [6]]])"+"\n-->Ellipsis expand to the number of : objects needed to make a selection tuple of the same length as x.ndim. There may only be a single ellipsis present.");
        listitemNumpies.add(listit);
        ListitemNumpy listi=new ListitemNumpy(
                "Example",
                ">>> x[...,0]\n" +
                        "array([[1, 2, 3],\n" +
                        "       [4, 5, 6]])"+"\nEach newaxis object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the newaxis object in the selection tuple");
        listitemNumpies.add(listi);
        ListitemNumpy list=new ListitemNumpy(
                "Example",
                ">>> x[:,np.newaxis,:,:].shape\n" +
                        "(2, 1, 3, 1)"+"\n-->An integer, i, returns the same values as i:i+1 except the dimensionality of the returned object is reduced by 1. In particular, a selection tuple with the p-th element an integer (and all other entries :) returns the corresponding sub-array with dimension N - 1. If N = 1 then the returned object is an array scalar. These objects are explained in Scalars.\n\n-->If the selection tuple has all entries : except the p-th entry which is a slice object i:j:k, then the returned array has dimension N formed by concatenating the sub-arrays returned by integer indexing of elements i, i+k, …, i + (m - 1) k < j,"+"\n-->Basic slicing with more than one non-: entry in the slicing tuple, acts like repeated application of slicing using a single non-: entry, where the non-: entries are successively taken (with all other non-: entries replaced by :). Thus, x[ind1,...,ind2,:] acts like x[ind1][...,ind2,:] under basic slicing.");
        listitemNumpies.add(list);
        ListitemNumpy lis=new ListitemNumpy(
                "Boolean array indexing",
                "This advanced indexing occurs when obj is an array object" +
                        " of Boolean type, such as may be returned from comparison " +
                        "operators. A single boolean index array is practically identical" +
                        " to x[obj.nonzero()] where, as described above, obj.nonzero() " +
                        "returns a tuple (of length obj.ndim) of integer index arrays" +
                        " showing the True elements of obj. However, it is faster when " +
                        "obj.shape == x.shape.\n\nIf obj.ndim == x.ndim, x[obj] returns " +
                        "a 1-dimensional array filled with the elements of x corresponding to the" +
                        " True values of obj. The search order will be row-major, C-style. If obj" +
                        "has True values at entries that are outside of the bounds of x, then an" +
                        " index error will be raised. If obj is smaller than x it is identical to " +
                        "filling it with False.");
        listitemNumpies.add(lis);
        ListitemNumpy li=new ListitemNumpy(
                "Example",
                "A common use case for this is filtering for desired element values. For example one may wish to select all entries from an array which are not NaN:" +
                        ">>> x = np.array([[1., 2.], [np.nan, 3.], [np.nan, np.nan]])\n" +
                        ">>> x[~np.isnan(x)]\n" +
                        "array([ 1.,  2.,  3.])\n\nOr wish to add a constant to all negative elements\n\nIn general if an index includes a Boolean array, the result will be identical to inserting obj.nonzero() into the same position and using the integer array indexing mechanism described above. x[ind_1, boolean_array, ind_2] is equivalent to x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]" +
                        "\n\nIf there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has exactly as many dimensions as it is supposed to work with.\n");
        listitemNumpies.add(li);
        ListitemNumpy l=new ListitemNumpy(
                "Index arrays",
                "NumPy arrays may be indexed with other arrays (or any other sequence- like object that can be converted to an array, such as lists, with the exception of tuples; see the end of this document for why this is). The use of index arrays ranges from simple, straightforward cases to complex, hard-to-understand cases. For all cases of index arrays, what is returned is a copy of the original data, not a view as one gets for slices.\n" +
                        "\n" +
                        "Index arrays must be of integer type. Each value in the array indicates " +
                        "which value in the array to use in place of the index. To illustrate:\n\n>>> x = np.arange(10,1,-1)\n" +
                        ">>> x\n" +
                        "array([10,  9,  8,  7,  6,  5,  4,  3,  2])\n" +
                        ">>> x[np.array([3, 3, 1, 8])]\n" +
                        "array([7, 7, 9, 2])\n\nThe index array consisting of the values 3, 3, 1 and 8 correspondingly create an array of length 4 (same as the index array) where each index is replaced by the value the index array has in the array being indexed.\n" +
                        "\n" +
                        "Negative values are permitted and work as they do with single indices or slices:\n\n>>> x[np.array([3,3,-3,8])]\n" +
                        "array([7, 7, 4, 2])\n\nIt is an error to have index values out of bounds:\n\n>>> x[np.array([3, 3, 20, 8])]\n" +
                        "<type 'exceptions.IndexError'>: index 20 out of bounds 0<=index<9\n\nGenerally speaking, what is returned when index arrays are used is an array with the same shape as the index array, but with the type and values of the array being indexed. As an example, we can use a multidimensional index array instead:\n\n" +
                        ">>> x[np.array([[1,1],[2,3]])]\n" +
                        "array([[9, 9],\n" +
                        "       [8, 7]]) ");
        listitemNumpies.add(l);
        ListitemNumpy k0=new ListitemNumpy(
                "Indexing Multi-dimensional arrays",
                "Things become more complex when multidimensional arrays are indexed, particularly with multidimensional index arrays. These tend to be more unusual uses, but they are permitted, and they are useful for some problems. We’ll start with the simplest multidimensional case (using the array y from the previous examples):\n\n>>> y[np.array([0,2,4]), np.array([0,1,2])]\n" +
                        "array([ 0, 15, 30])\n\nIn this case, if the index arrays have a matching shape, and there is an index array for each dimension of the array being indexed, the resultant array has the same shape as the index arrays, and the values correspond to the index set for each position in the index arrays. In this example, the first index value is 0 for both index arrays, and thus the first value of the resultant array is y[0,0]. The next value is y[2,1], and the last is y[4,2].\n" +
                        "\n" +
                        "If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised:\n\n>>> y[np.array([0,2,4]), np.array([0,1])]\n" +
                        "<type 'exceptions.ValueError'>: shape mismatch: objects cannot be\n" +
                        "broadcast to a single shape\n\nThe broadcasting mechanism permits index arrays to be combined with scalars for other indices. The effect is that the scalar value is used for all the corresponding values of the index arrays:\n\n>>> y[np.array([0,2,4]), 1]\n" +
                        "array([ 1, 15, 29])\n\nJumping to the next level of complexity, it is possible to only partially index an array with index arrays. It takes a bit of thought to understand what happens in such cases. For example if we just use one index array with y:\n\n>>> y[np.array([0,2,4])]\n" +
                        "array([[ 0,  1,  2,  3,  4,  5,  6],\n" +
                        "       [14, 15, 16, 17, 18, 19, 20],\n" +
                        "       [28, 29, 30, 31, 32, 33, 34]])\n\nWhat results is the construction of a new array where each value of the index array selects one row from the array being indexed and the resultant array has the resulting shape (number of index elements, size of row).\n" +
                        "\n" +
                        "An example of where this may be useful is for a color lookup table where we want to map the values of an image into RGB triples for display. The lookup table could have a shape (nlookup, 3). Indexing such an array with an image with shape (ny, nx) with dtype=np.uint8 (or any integer type so long as values are with the bounds of the lookup table) will result in an array of shape (ny, nx, 3) where a triple of RGB values is associated with each pixel location.\n" +
                        "\n" +
                        "In general, the shape of the resultant array will be the concatenation of the shape of the index array (or the shape that all the index arrays were broadcast to) with the shape of any unused dimensions (those not indexed) in the array being indexed.");
        listitemNumpies.add(k0);
        ListitemNumpy k=new ListitemNumpy(
                "Combining index arrays with slices",
                "Index arrays may be combined with slices. For example:\n" +
                        "\n" +
                        ">>> y[np.array([0,2,4]),1:3]\n" +
                        "array([[ 1,  2],\n" +
                        "       [15, 16],\n" +
                        "       [29, 30]])\n" +
                        "In effect, the slice is converted to an index array np.array([[1,2]]) (shape (1,2)) that is broadcast with the index array to produce a resultant array of shape (3,2).\n" +
                        "\n" +
                        "Likewise, slicing can be combined with broadcasted boolean indices:\n" +
                        "\n" +
                        ">>> y[b[:,5],1:3]\n" +
                        "array([[22, 23],\n" +
                        "       [29, 30]])");
        listitemNumpies.add(k);
        ListitemNumpy k1=new ListitemNumpy(
                "Structural indexing tools",
                "To facilitate easy matching of array shapes with expressions and in assignments, the np.newaxis object can be used within array indices to add new dimensions with a size of 1. For example:\n" +
                        "\n" +
                        ">>> y.shape\n" +
                        "(5, 7)\n" +
                        ">>> y[:,np.newaxis,:].shape\n" +
                        "(5, 1, 7)\n" +
                        "Note that there are no new elements in the array, just that the dimensionality is increased. This can be handy to combine two arrays in a way that otherwise would require explicitly reshaping operations. For example:\n" +
                        "\n" +
                        ">>> x = np.arange(5)\n" +
                        ">>> x[:,np.newaxis] + x[np.newaxis,:]\n" +
                        "array([[0, 1, 2, 3, 4],\n" +
                        "       [1, 2, 3, 4, 5],\n" +
                        "       [2, 3, 4, 5, 6],\n" +
                        "       [3, 4, 5, 6, 7],\n" +
                        "       [4, 5, 6, 7, 8]])\n" +
                        "The ellipsis syntax maybe used to indicate selecting in full any remaining unspecified dimensions. For example:\n" +
                        "\n" +
                        ">>> z = np.arange(81).reshape(3,3,3,3)\n" +
                        ">>> z[1,...,2]\n" +
                        "array([[29, 32, 35],\n" +
                        "       [38, 41, 44],\n" +
                        "       [47, 50, 53]])\n" +
                        "This is equivalent to:\n" +
                        "\n" +
                        ">>> z[1,:,:,2]\n" +
                        "array([[29, 32, 35],\n" +
                        "       [38, 41, 44],\n" +
                        "       [47, 50, 53]])");
        listitemNumpies.add(k1);

        ListitemNumpy k7=new ListitemNumpy(
                "Assigning values to indexed arrays",
                "As mentioned, one can select a subset of an array to assign to using a single index, slices, and index and mask arrays. The value being assigned to the indexed array must be shape consistent (the same shape or broadcastable to the shape the index produces). For example, it is permitted to assign a constant to a slice:\n" +
                        "\n" +
                        ">>> x = np.arange(10)\n" +
                        ">>> x[2:7] = 1\n" +
                        "or an array of the right size:\n" +
                        "\n" +
                        ">>> x[2:7] = np.arange(5)\n" +
                        "Note that assignments may result in changes if assigning higher types to lower types (like floats to ints) or even exceptions (assigning complex to floats or ints):\n" +
                        "\n" +
                        ">>> x[1] = 1.2\n" +
                        ">>> x[1]\n" +
                        "1\n" +
                        ">>> x[1] = 1.2j\n" +
                        "<type 'exceptions.TypeError'>: can't convert complex to long; use\n" +
                        "long(abs(z))\n" +
                        "Unlike some of the references (such as array and mask indices) assignments are always made to the original data in the array (indeed, nothing else would make sense!). Note though, that some actions may not work as one may naively expect. This particular example is often surprising to people:\n" +
                        "\n" +
                        ">>> x = np.arange(0, 50, 10)\n" +
                        ">>> x\n" +
                        "array([ 0, 10, 20, 30, 40])\n" +
                        ">>> x[np.array([1, 1, 3, 1])] += 1\n" +
                        ">>> x\n" +
                        "array([ 0, 11, 20, 31, 40])\n" +
                        "Where people expect that the 1st location will be incremented by 3. In fact, it will only be incremented by 1. The reason is because a new array is extracted from the original (as a temporary) containing the values at 1, 1, 3, 1, then the value 1 is added to the temporary, and then the temporary is assigned back to the original array. Thus the value of the array at x[1]+1 is assigned to x[1] three times, rather than being incremented 3 times.");
        listitemNumpies.add(k7);
        ListitemNumpy k8=new ListitemNumpy(
                "Dealing with variable numbers of indices within programs",
                "The index syntax is very powerful but limiting when dealing with a variable number of indices. For example, if you want to write a function that can handle arguments with various numbers of dimensions without having to write special case code for each number of possible dimensions, how can that be done? If one supplies to the index a tuple, the tuple will be interpreted as a list of indices. For example (using the previous definition for the array z):\n" +
                        "\n" +
                        ">>> indices = (1,1,1,1)\n" +
                        ">>> z[indices]\n" +
                        "40\n" +
                        "So one can use code to construct tuples of any number of indices and then use these within an index.\n" +
                        "\n" +
                        "Slices can be specified within programs by using the slice() function in Python. For example:\n" +
                        "\n" +
                        ">>> indices = (1,1,1,slice(0,2)) # same as [1,1,1,0:2]\n" +
                        ">>> z[indices]\n" +
                        "array([39, 40])\n" +
                        "Likewise, ellipsis can be specified by code by using the Ellipsis object:\n" +
                        "\n" +
                        ">>> indices = (1, Ellipsis, 1) # same as [1,...,1]\n" +
                        ">>> z[indices]\n" +
                        "array([[28, 31, 34],\n" +
                        "       [37, 40, 43],\n" +
                        "       [46, 49, 52]])\n" +
                        "For this reason it is possible to use the output from the np.nonzero() function directly as an index since it always returns a tuple of index arrays.\n" +
                        "\n" +
                        "Because the special treatment of tuples, they are not automatically converted to an array as a list would be. As an example:\n" +
                        "\n" +
                        ">>> z[[1,1,1,1]] # produces a large array\n" +
                        "array([[[[27, 28, 29],\n" +
                        "         [30, 31, 32], ...\n" +
                        ">>> z[(1,1,1,1)] # returns a single value\n" +
                        "40");
        listitemNumpies.add(k8);
        ListitemNumpy k9=new ListitemNumpy(
                "\n",
                "\n");
        listitemNumpies.add(k9);








        adapter =new numpyAdapter( listitemNumpies,getActivity() );
        recyclerView.setAdapter( adapter );
        return rootView;
    }

}
